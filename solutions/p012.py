from collections import Counter
from functools import reduce
from math import sqrt
from operator import mul

from pyler.pyler import EulerProblem
from utils.prime_generator import rwh_primes
from utils.primes import prime_factors


class Problem0012(EulerProblem):
    """
    The sequence of triangle numbers is generated by adding the natural numbers.
    So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
    first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ... Let us
    list the factors of the first seven triangle numbers:  1: 1 3: 1,3 6:
    1,2,3,610: 1,2,5,1015: 1,3,5,1521: 1,3,7,2128: 1,2,4,7,14,28 We can see that
    28 is the first triangle number to have over five divisors. What is the
    value of the first triangle number to have over five hundred divisors?
    """

    problem_id = 12
    simple_input = 5
    simple_output = 28
    real_input = 500
    real_output = 76576500

    @staticmethod
    def solver(input_val):
        index = 1
        triangle_number = 1  # n-th triangle number
        nb_divisors = 0
        while nb_divisors <= input_val:
            nb_divisors = 0
            index += 1
            triangle_number += index
            for i in range(1, int(sqrt(triangle_number)) + 1):
                if triangle_number % i == 0:
                    nb_divisors += 2
            if triangle_number == int(sqrt(triangle_number)) ** 2:  # for a perfect square
                nb_divisors -= 1
        return triangle_number

    @staticmethod
    def solver2(input_val):
        """
        Any integer N can be expressed as follows:
        N = p1^a1 * p2^a2 * p3^a3 * ...
        where pn is a distinct prime number, and an is its exponent.
        For example, 28 = 2^2 * 7^1
        Furthermore, the number of divisors D(N) of any integer N can be computed from:
        D(N) = (a1+1) * (a2+1) * (a3+1) * ...
        an being the exponents of the distinct prime numbers which are factors of N
        For example, the number of divisors of 28 would thus be:
        D(28) = (2+1)*(1+1) = 3*2 = 6
        A table of primes will be required to apply this relationship. The efficient preparation of a prime
        table is already covered in the overview for Problem 7 and will not be discussed here. Since the
        largest expected triangle number is within a 32-bit integer, a table containing primes up to 65500
        would be more than sufficient. The following code assumes that this array of primes is already
        available.
        """
        def triangle_numbers(limit):
            """Generates triangle numbers."""
            triangle_number = 1
            for i in range(2, limit):
                yield triangle_number
                triangle_number += i

        primes = rwh_primes(10 ** 5)
        for number in triangle_numbers(10 ** 5):
            number_temp = number
            prime_factors_pow = []
            if number < 2:
                prime_factors_pow.append(0)
            for p in primes:
                if p > number_temp:
                    break
                n = 0
                while number_temp % p == 0:
                    n += 1
                    number_temp //= p
                prime_factors_pow.append(n)
            num_divisors = reduce(mul, [k + 1 for k in prime_factors_pow])
            if num_divisors >= input_val:
                return number

    @staticmethod
    def solver3(input_val):
        """ Same idea but using built-in functions for speed """
        n, nb_divisors = 1, 1

        while nb_divisors < input_val:
            n += 1
            factors = Counter(prime_factors(n * (n + 1) // 2))
            nb_divisors = reduce(mul, [x + 1 for x in factors.values()])

        return n * (n + 1) // 2

    @staticmethod
    def solver4(input_val):
        """
        The above can still be improved a lot by considering the fact that triangle numbers can also be
        obtained according to:
        t = n((n+1)/2
        The n and n+1 components are necessarily co-prime (i.e. cannot have any common prime factor
        and therefore no common divisor). The total number of divisors of t can thus be obtained
        according to:
        D(t) = D(n/2) * (D(n+1) if n is even
        or D(t) = D(n) * (D((n+1)/2) if (n+1) is even
        Each component being much smaller than the triangle number itself, it would be much faster to
        determine the divisors of each. And, the required table of primes will also be that much smaller
        and faster to prepare. Primes up to only 1000 will be more than adequate for this problem. In
        addition, the result of the “n+1" component can be reused as that of the “n” component for the
        next triangle number without any need to compute it a second time.
        """
        n = 3  # start with the third triangle number
        nb_divisors_prev = 2  # number of divisors of the "n" component
        nb_divisors = 0  # number of divisors for the n-th triangle number
        primes = rwh_primes(1000)

        while nb_divisors <= input_val:
            next_n = n + 1
            if next_n % 2 == 0:
                next_n /= 2
            nb_divisors_next = 1  # number of divisors of the "n+1" component
            for i in range(len(primes) + 1):
                if primes[i] * primes[i] > next_n:
                    nb_divisors_next *= 2
                    break
                exponent = 1
                while next_n % primes[i] == 0:
                    exponent += 1
                    next_n /= primes[i]
                if exponent > 1:
                    nb_divisors_next *= exponent
                if next_n == 1:
                    break
            nb_divisors = nb_divisors_prev * nb_divisors_next
            nb_divisors_prev = nb_divisors_next
            n += 1
        return n * (n-1) / 2


if __name__ == "__main__":
    import unittest
    unittest.main()
